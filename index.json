[{"categories":null,"content":"该漏洞在Pwn2Own 2021中被利用，提交者在相关issue中提交了exploit。关于漏洞的修补可以查看对应commit。 从diff结果可以看出修补的措施很简单：在修补之前，opcode可能为kX64Movsxlq，对应符号扩展；也可能为kX64Movl，对应零扩展。 diff --git [a/src/compiler/backend/x64/instruction-selector-x64.cc](https://chromium.googlesource.com/v8/v8/+/720176a523544721973a8ceba89e9c7af9405963/src/compiler/backend/x64/instruction-selector-x64.cc) [b/src/compiler/backend/x64/instruction-selector-x64.cc](https://chromium.googlesource.com/v8/v8/+/3066b7b2fcb3aa66541a4818e1165e34acc52639/src/compiler/backend/x64/instruction-selector-x64.cc) index 7df4fcb..424edf5 100644 --- a/src/compiler/backend/x64/instruction-selector-x64.cc +++ b/src/compiler/backend/x64/instruction-selector-x64.cc @@ -1279,7 +1279,9 @@ opcode = load_rep.IsSigned() ? kX64Movsxwq : kX64Movzxwq; break; case MachineRepresentation::kWord32: - opcode = load_rep.IsSigned() ? kX64Movsxlq : kX64Movl; + // ChangeInt32ToInt64 must interpret its input as a _signed_ 32-bit + // integer, so here we must sign-extend the loaded value in any case. + opcode = kX64Movsxlq; break; default: UNREACHABLE(); 关于该漏洞，网上的poc有很多，这里仅贴出其中之一： glob = {}; function foo(flag) { let bad = b[0] ^ 0; bad += 1; let i = Math.max(Math.max(0, bad) - 0x7fffffff, 0) \u003e\u003e 1; // expected: 0, actual: 1 glob[i] = 1; if (flag) { i = -1; } let v4 = Math.sign(i); v4 = Math.sign(i) \u003c 0 ? 0 : v4; let v5 = new Array(v4); v5.shift(); return v5; } var b = new Uint32Array([0x80000000]); for (let i = 0; i \u003c 200000; ++i) { foo(true); } oob = foo(false); 执行poc脚本，结果如下： poc执行结果\r可以看见oob数组的长度为-1。漏洞出现在以下代码的编译优化阶段： function foo(flag) { let bad = b[0] ^ 0; bad += 1; //... } 使用Turbolizer查看foo函数编译优化各阶段的graph，在SimplifiedLowering阶段中，漏洞代码对应的nodes如下： SimplifiedLowering阶段\r在EarlyOptimization阶段中可以观察到，ChangeInt32ToInt64节点的输入由之前的Signed32变为了Unsigned32，实际上这就是漏洞所在之处。 EarlyOptimization阶段\r结合diff文件中修补前的内容，得知对于ChangeInt32ToInt64节点而言，如果输入类型为Unsigned，opcode将选择kX64Movl。kX64Movl相当于mov指令，它使输入在ChangeInt32ToInt64节点中作零扩展。 这有什么影响呢？对于poc脚本中的b[0]（即0x80000000），当其作符号扩展时，结果为0xFFFF FFFF 8000 0000；当其作零扩展时，结果为0x0000 0000 8000 0000。容易看出，前者为负，后者为正。 在编译优化进行之前，因为对b[0] ^ 0结果进行的是符号扩展，所以以下代码的结果为0；但在编译优化进行之后，因为对b[0] ^ 0结果进行的是零扩展，所以以下代码的结果应为1（即2 » 1）。 let i = Math.max(Math.max(0, bad) - 0x7fffffff, 0) \u003e\u003e 1; // expected: 0, actual: 1 在执行以下代码时，因为foo函数已经过编译优化，且传入的flag为false，所以得到的v5应为一个长度为1的Array。这是TurboFan预期之外的，因为在此之前foo函数的200000次执行中，v5的长度均为0，而此时其长度为1。 oob = foo(false); 观察编译优化后shift函数对应的汇编代码，可以看到movl [rdi+0xb],0xfffffffe，它将0xfffffffe写入[rdi+0xb]中。 编译优化后shift函数对应的汇编代码\rV8中的指针为tagged value，最低位为1；而rdi中保存的就是一个Array对象的指针，因此其最低位也为1。V8中数组对象的数据结构如下图，图中每个长方形代表的长度为4字节： V8中数组对象的数据结构\r综上所述，rdi+0xb实际为数组对象中的length字段的指针，所以movl [rdi+0xb], 0xfffffffe则是向length字段写入0xfffffffe。在V8中，Smi也是tagged value，与指针的区别是Smi的最低位为0，因此0xfffffffe代表的值实际为-1，即优化后所得的汇编程序将v5的长度设置为了-1。 为什么数组长度会变为-1？因为编译优化在很大程度上是根据之前解释执行时收集的数据类型信息来进行的。在之前foo函数的多次执行中，v5的长度总为0，所以TurboFan记住了这一点。shift函数将数组的第一个元素从数组中取出，并将数组长度length减1，因此在修改数组长度时总是进行0-1的计算。TurboFan为了提高性能，进行了常量折叠，即在为数组长度赋值时，直接向length字段写入0xfffffffe。 至于为什么数组长度为0时，shift函数还要将length减1，可能需要看看函数shift的源码实现才能够解释。我的一个理解是，这是为了编译后的运行效率所做的一种妥协。 综上，在编译优化后，“意外\"地出现了一个长度为1的v5数组，由此导致了oob。 之后的利用很常见，将shellcode写入WASM对应的RXW段并执行即可。 ","date":"2022-09-30","objectID":"/cve-2021-21220%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:0:0","tags":["V8","浏览器","Chrome"],"title":"CVE-2021-21220漏洞分析","uri":"/cve-2021-21220%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About LoveIt","uri":"/about/"}]
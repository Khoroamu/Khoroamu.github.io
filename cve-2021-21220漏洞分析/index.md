# CVE-2021-21220漏洞分析


## 漏洞背景

该漏洞在Pwn2Own 2021中被利用，提交者在[相关issue](https://bugs.chromium.org/p/chromium/issues/detail?id=1196683)中提交了exploit。关于漏洞的修补可以查看对应[commit](https://chromium.googlesource.com/v8/v8/+/3066b7b2fcb3aa66541a4818e1165e34acc52639%5E%21/)。

## 漏洞分析

从diff结果可以看出修补的措施很简单：在修补之前，`opcode`可以为`kX64Movsxlq`，对应[符号扩展](https://zh.m.wikipedia.org/zh-hans/%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%85%85)；也可以为`kX64Movl`，对应[零扩展](https://zh.m.wikipedia.org/zh-hans/%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%85%85)。

```diff
diff --git [a/src/compiler/backend/x64/instruction-selector-x64.cc](https://chromium.googlesource.com/v8/v8/+/720176a523544721973a8ceba89e9c7af9405963/src/compiler/backend/x64/instruction-selector-x64.cc) [b/src/compiler/backend/x64/instruction-selector-x64.cc](https://chromium.googlesource.com/v8/v8/+/3066b7b2fcb3aa66541a4818e1165e34acc52639/src/compiler/backend/x64/instruction-selector-x64.cc)
index 7df4fcb..424edf5 100644
--- a/src/compiler/backend/x64/instruction-selector-x64.cc
+++ b/src/compiler/backend/x64/instruction-selector-x64.cc

@@ -1279,7 +1279,9 @@
         opcode = load_rep.IsSigned() ? kX64Movsxwq : kX64Movzxwq;
         break;
       case MachineRepresentation::kWord32:
-        opcode = load_rep.IsSigned() ? kX64Movsxlq : kX64Movl;
+        // ChangeInt32ToInt64 must interpret its input as a _signed_ 32-bit
+        // integer, so here we must sign-extend the loaded value in any case.
+        opcode = kX64Movsxlq;
         break;
       default:
         UNREACHABLE();
```

关于该漏洞，网上的poc有很多，这里仅贴出其中之一：

```js
glob = {};
function foo(flag) {
    let bad = b[0] ^ 0;
    bad += 1;
    let i = Math.max(Math.max(0, bad) - 0x7fffffff, 0) >> 1;  // expected: 0, actual: 1 
    glob[i] = 1;
    if (flag) {
        i = -1;
    }
    let v4 = Math.sign(i);
    v4 = Math.sign(i) < 0 ? 0 : v4;
    let v5 = new Array(v4);
    v5.shift();
    return v5;
}
var b = new Uint32Array([0x80000000]);
for (let i = 0; i < 200000; ++i) {
    foo(true);
}
oob = foo(false);
```

执行poc脚本，结果如下：

![](https://raw.githubusercontent.com/Khoroamu/pictures/master/pic/Pasted%20image%2020220515161132.png "poc执行结果")

可以看见`oob`数组的长度为-1，在正常情况下这是不可能的。根据网上提供的信息，漏洞出现在以下代码的编译优化阶段：

```js
function foo(flag) {
    let bad = b[0] ^ 0;
    bad += 1;
//...
}
```

使用Turbolizer查看`foo`函数编译优化各阶段的graph。

> 在编译优化的`SimplifiedLowering`阶段，主要的工作是根据数据流分析把`Simplified Node`降级到更具体的`Machine Node`。

在`SimplifiedLowering`阶段中，漏洞代码对应的nodes如下：

![](https://raw.githubusercontent.com/Khoroamu/pictures/master/pic/Pasted%20image%2020220516014632.png "SimplifiedLowering阶段")

随后是`EarlyOptimization`阶段，在`EarlyOptimization`阶段中可以观察到，`ChangeInt32ToInt64`节点的输入由之前的`Signed32`变为了`Unsigned32`。根据已有的资料获知，实际上这就是**漏洞**所在之处。

![](https://raw.githubusercontent.com/Khoroamu/pictures/master/pic/Pasted%20image%2020220516014212.png "EarlyOptimization阶段")

结合diff文件中修补前的内容，得知对于`ChangeInt32ToInt64`节点而言，如果输入类型为`Unsigned`，`opcode`将选择`kX64Movl`。`kX64Movl`相当于`mov`指令，它使输入在`ChangeInt32ToInt64`节点中作**零扩展**。

这有什么影响呢？对于poc脚本中的`b[0]`（即**0x8000 0000**），当其作符号扩展时，结果为**0xFFFF FFFF 8000 0000**；而当其作零扩展时，结果为**0x0000 0000 8000 0000**。容易看出，**前者为负，后者为正**。

在编译优化进行之前，因为对`b[0] ^ 0`结果进行的是**符号扩展**，所以`bad`的值在加1后为**0xFFFF FFFF 8000 0001**，最终`i`的值为**0**；但在编译优化进行之后，因为对`b[0] ^ 0`结果进行的是**零扩展**，所以`bad`的值在加1后为**0x0000 0000 8000 0001**，最终`i`的值应为**1**（即**2 >> 1**）。

```js
function foo(flag) {
    let bad = b[0] ^ 0;
    bad += 1;
    let i = Math.max(Math.max(0, bad) - 0x7fffffff, 0) >> 1;  // expected: 0, actual: 1 
	// ...
}
```

在执行以下代码[*]时，因为`foo`函数已经过编译优化，且传入的`flag`为`false`，所以得到的`v5`应为一个长度为1的Array。这是TurboFan预期之外的，因为在此之前`foo`函数的200000次执行中，`v5`的长度均为0，而此时其长度为1。

```js
// ...
function foo(flag) {
    // ...
    if (flag) {
        i = -1;
    }
    let v4 = Math.sign(i);	// flag为false时，i为1，则v4为1
    v4 = Math.sign(i) < 0 ? 0 : v4;
    let v5 = new Array(v4);
    v5.shift();
    return v5;
}
// ...
for (let i = 0; i < 200000; ++i) {
    foo(true);
}
oob = foo(false);	// [*]
```

观察编译优化后`shift`函数对应的汇编代码，可以看到`movl [rdi+0xb],0xfffffffe`，它将0xfffffffe写入`[rdi+0xb]`中。

![](https://raw.githubusercontent.com/Khoroamu/pictures/master/pic/Pasted%20image%2020220516030757.png "编译优化后shift函数对应的汇编代码")

V8中的指针为`tagged value`，最低位为1；而`rdi`中保存的就是一个Array对象的指针，因此其最低位也为1。V8中数组对象的数据结构如下图，图中每个长方形代表的长度为4字节：

![](https://raw.githubusercontent.com/Khoroamu/pictures/master/pic/Pasted%20image%2020220516033130.png "V8中数组对象的数据结构")

综上所述，`rdi+0xb`实际为数组对象中的`length`字段的指针，所以`movl [rdi+0xb], 0xfffffffe`则是向`length`字段写入0xfffffffe。在V8中，`Smi`也是`tagged value`，与指针的区别是`Smi`的最低位为0，因此0xfffffffe代表的值实际为-1，即优化后所得的汇编程序将`v5`的长度设置为了-1。

为什么数组长度会变为-1？因为编译优化在很大程度上是根据之前解释执行时收集的数据类型信息来进行的。在之前`foo`函数的多次执行中，`v5`的长度总为0，所以TurboFan记住了这一点。`shift`函数将数组的第一个元素从数组中取出，并将数组长度`length`减1，因此在修改数组长度时总是进行`0-1`的计算。TurboFan为了提高性能，进行了**常量折叠**，即在为数组长度赋值时，直接向`length`字段写入0xfffffffe。

至于为什么数组长度为0时，`shift`函数还要将`length`减1，可能需要看看函数`shift`的源码实现才能够解释。我的理解是，这是为了编译后的运行效率所做的一种妥协。

综上，在编译优化后，"意外"地出现了一个长度为1的有效数组`v5`，由此导致了oob。

之后的利用很常见，构造`addressOf`和`fakeObj`原语，将shellcode写入WASM对应的`RXW`段并执行即可。

